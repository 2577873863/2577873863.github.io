(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-61ecc344"],{"1e75":function(n,e,t){"use strict";t("b00e")},b00e:function(n,e,t){},f574:function(n,e,t){"use strict";t.r(e);var o=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"container"},[t("div",{staticClass:"markdown-view"},[t("mavon-editor",{attrs:{value:n.mdText,editable:!1,toolbarsFlag:!1,subfield:!1,defaultOpen:"preview",navigation:!0}})],1)])},i=[],r='\n## 1.Electron介绍\n* Electron 是由 Github开发的开源框架\n* 它允许开发者使用Web技术构建跨平台的桌面应用\n![electron的构成](http://newimg.jspang.com/web111111.jpg)\n* Electron = Chromium + Node.js + Native API\n  *  Chromium：为Electron提供了强大的UI能力，可以不考虑兼容性的情况下，使用强大的web生态来开发界面\n  *  Node.js：让Electron有了底层的操作能力，比如文件的读写，甚至是集成C++等等操作，并可以使用大量的开源=-npm=-包来完成开发\n  *  Native API：Native API让Electron有了跨平台和桌面端的原生能力，比如它具有用提的原生界面，窗口，托盘..\n  \n## 2.Electron开发环境的搭建\n0. 创建项目文件夹\n1. 使用=-npm=-初始化文件夹\n    -=\n    npm init -y\n    -=\n2. 安装Electron \n    -=\n    npm install electron --save-dev\n    -=\n3. 检查是否安装成功|检测版本 (两个命令都可以)\n    -=\n    npx electron -v \n    ./node_modules/.bin/electron -v (cnpm安装的此命令不行)  \n    -=\n    * 成功会出现版本号 例：  =-v8.0.0=- \n    * 失败会需要再次下载，可能需要翻墙或者换源 \n    * 失败提示:=-Electron failed to install correctly, please delete node_modules/electron and try installing again=-\n4. 运行electron示例\n    * 在=-package.json=-文件的=-scripts=-选项中添加\n    -=\n    "dev":"./node_modules/.bin/electron"\n    -=\n    * 在命令行执行  =-npm run dev=-\n    \n    * 运行结果\n        ![运行结果](http://newimg.jspang.com/ElectronDemo2.png)\n\n\n## 3.Electron的第一个例子\n1. 创建文件夹\n2. 使用=-npm=-初始文件夹\n    -=\n    npm init -y\n    npm init --yes\n    -=\n3. 安装Electron\n    -=\n    cnpm install electron --save-dev\n    -=\n4. 创建页面(index.html)，代码如下：\n    -= html\n    <!DOCTYPE html>\n    <html lang="en">\n    <head>\n      <meta charset="UTF-8">\n      <meta name="viewport" content="width=device-width, initial-scale=1.0">\n      <meta http-equiv="X-UA-Compatible" content="ie=edge">\n      <title>Electron案例1</title>\n    </head>\n    <body>\n      <h2>Hello World</h2>\n      <hr>\n      <h2>Hello Electron</h2>\n    </body>\n    </html>\n    -=\n5. 创建主进程(main.js)，代码如下：\n    -= js\n    const electron = require(\'electron\');\n\n    const app = electron.app; //引用app\n    const BrowserWindow = electron.BrowserWindow; //引用窗口\n    \n    let mainWindow = null; //要打开的主窗口\n    \n    app.on(\'ready\',()=>{\n      //https://www.electronjs.org/docs/api/browser-window\n      mainWindow = new BrowserWindow({ //创建窗口\n        width:300, //页面的宽度，单位px -默认800\n        height:300  //页面的高度，单位px -默认800\n      });\n      mainWindow.loadFile(\'index.html\'); //加载html页面\n    \n      mainWindow.on(\'closed\',()=>{ //关闭时清除窗口，不然会一直占用内存\n        mainWindow = null;\n      })\n    })\n    -=\n6. 修改=-package.json=-的=-scripts=-选项，如下：\n    -= js\n    "scripts": {\n        "start":"electron ."\n    },\n    -=\n7. 运行=-npm run start=-\n\n8. 运行结果\n\n    ![案例运行结果](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGubNt7ix2ndDtAr0ZKs1SaSOCblK6dztFeXwYOGhq3D*2g3cUVxnWSIY*LysMpXp2Zb1HtT03CQEk3*tbwo6TXg!/r)\n\n\n\n## 4.Electron运行流程(附读取文件案例)\n* Electron分为**主进程**和**渲染进程**\n  * 一个Electron项目可以有**多个**渲染进程，但是只能**有且只有一个**主进程\n  * 主进程控制渲染进程，一个主进程可以控制多个渲染进程\n  ![渲染进程和主进程](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGmV66XGpPlWHOCcFH2*J7yeEQeiTnxV8bFsZH2vjQ.H7Ll*ML0bCYaEvP7YNMaMVcLMXxc*qnQA2uC.*vqlsGWk!/r)\n* Electron运行流程\n  ![运行流程图](http://newimg.jspang.com/electrondemo1.png)\n    1. Electron会读取=-package.json=-的=-main=-来决定谁是**主进程**\n        * 例如=-"main":"main.js"=-那么主进程就是=-main.js=-  *Electron会在 __主进程中找渲染进程__*\n    2.  =-main.js=-(主进程文件)中创建**渲染进程**(=-mainWindow.loadFile(\'index.html\')=-) \n    3.  读取页面(渲染进程)的布局和样式(UI)\n    4.  使用IPC(进程见通信)在主进程执行任务并获取信息\n* 读取文件案例\n  * 文件目录\n    -= json\n    project\n    ├─node_modules\n    ├─data.txt\n    ├─index.html\n    ├─index.js\n    ├─package.json\n    ├─render\n    |   └render.js\n    -=\n  * data.txt文件内容\n    -=\n    我是文件 data.txt 的内容，点击按钮我就会出现（此内容无所谓，可修改）\n    -=\n  * index.html(渲染进程)文件内容\n    -= html\n    <!DOCTYPE html>\n    <html lang="en">\n    <head>\n      <meta charset="UTF-8">\n      <meta name="viewport" content="width=device-width, initial-scale=1.0">\n      <meta http-equiv="X-UA-Compatible" content="ie=edge">\n      <title>读取文件案例</title>\n    </head>\n    <body>\n      <button class="btn1">点击读取文件</button>\n      <div class="container"></div>\n      \x3c!--引入js文件--\x3e\n      <script src="render/render.js"><\/script>\n    </body>\n    </html>\n    -=\n  * index.js(主进程)文件内容\n    -= js\n    const electron = require(\'electron\');\n\n    const app = electron.app;\n    const BrowserWindow = electron.BrowserWindow;\n    \n    let mainWindow = null;\n    \n    app.on(\'ready\',()=>{\n      mainWindow = new BrowserWindow({\n        width:800,\n        height:600,\n        webPreferences:{  //网页功能的设置\n        //创建BrowserWindow的时候指定nodeIntegration为false。 这样在electron内置浏览器里面不会有module和require全局变量。\n          nodeIntegration:true //是否集成node(使用node模块) -默认为false\n        }\n      })\n      mainWindow.loadFile(\'index.html\');\n      mainWindow.on(\'closed\',()=>{\n        mainWindow = null;\n      })\n    })\n    -=\n  * render/render.js文件内容\n    -= js\n    const fs = require(\'fs\'); //引入node的fs模块 需要在渲染进程里面写东西\n\n    window.onload = function(){\n      let btn = document.querySelector(\'.btn1\');\n      let container = document.querySelector(\'.container\');\n      btn.addEventListener(\'click\',()=>{\n         fs.readFile(\'data.txt\',(err,data)=>{ //读取文件\n          if(err){\n            container.innerHTML = \'读取文件失败\'\n          }else{\n            container.innerHTML = data;\n          }\n        });\n      })\n    }\n    -=\n  * package.json文件内容\n    -= json\n    {\n      "name": "study_2",\n      "version": "1.0.0",\n      "description": "",\n      "main": "index.js",\n      "scripts": {\n        "electron":"electron ."\n      },\n      "keywords": [],\n      "author": "",\n      "license": "ISC",\n      "devDependencies": {\n        "electron": "^8.0.0"\n      }\n    }\n    -=\n  * 运行\n    -=\n    npm run electron\n    yarn electron\n    -=\n  * 运行结果\n  ![运行结果](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGvUYnwEGxx05y5X*otz8ayU8l24FbpGkNcHamP9L41J1xQhO9NQ2ShZM8cp66zjirsoAA1hshUOBJixdI76h.HY!/r)\n\n\n\n## 5.Electron的remote模块\n> [remote](https://www.electronjs.org/docs/api/remote)在渲染进程中使用主进程模块,\nremote 模块为渲染进程（web页面）和主进程通信（IPC）提供了一种简单方法。例如：从渲染进程创建浏览器窗口\n* 借助=-remote=-Electron的API方法和模块也是分为可以在主进程和渲染进程中使用。\n\n### 从渲染进程创建浏览器窗口案例\n* 文件目录\n  -=\n  ├─index.html      --    渲染进程\n  ├─index.js        --    主进程\n  ├─index2.html     --    页面2\n  ├─package.json    --    package.json文件\n  ├─render      \n  |   └render.js    --    渲染进程逻辑\n  -=\n* =-index.html=-渲染进程文件内容\n  -= html\n  <!DOCTYPE html>\n  <html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>remote模块</title>\n  </head>\n  <body>\n    <button class="btn1">点击出现新页面</button>\n    <script src="render/render.js"><\/script>\n  </body>\n  </html>\n  -=\n* =-index.js=-主进程文件\n  -= js\n  const electron = require(\'electron\');\n  const {app,BrowserWindow} = electron;\n  let mainWindow = null;\n  app.on(\'ready\', () => {\n    mainWindow = new BrowserWindow({\n      width: 800,\n      height: 500,\n      webPreferences: {\n        //这里一定要写，不然在render.js里面无法使用js模块\n        nodeIntegration: true\n      }\n    });\n    mainWindow.loadFile(\'index.html\');\n    mainWindow.on(\'closed\', () => {\n      mainWindow = null;\n    })\n  });\n  -=\n* =-index2.html=-页面2文件内容\n  -= html\n  <!DOCTYPE html>\n  <html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>子页面</title>\n  </head>\n  <body style="background: #23da93;">\n    <h1>我是新打开的页面</h1>\n  </body>\n  </html>\n  -=\n* =-render/render.js=-文件内容\n  -= js\n  let btn1 = document.querySelector(\'.btn1\');\n  //在渲染进程中使用主进程模块需要使用remote\n  let { BrowserWindow } = require(\'electron\').remote;\n  btn1.addEventListener(\'click\',()=>{\n    const {BrowserWindow} = require(\'electron\').remote;\n    let win = new BrowserWindow({\n      width:500,\n      height:500\n    });\n    win.loadFile(\'index2.html\');\n    win.on(\'closed\',()=>{\n      win = null;\n    })\n  })\n  -=\n* =-package.json=-文件内容\n  -= json\n  {\n    "name": "study_3",\n    "version": "1.0.0",\n    "description": "",\n    "main": "index.js",\n    "scripts": {\n      "start":"electron ."\n    },\n    "keywords": [],\n    "author": "",\n    "license": "ISC",\n    "devDependencies": {\n      "electron": "^8.0.0"\n    }\n  }\n  -=\n* 在命令行中执行\n  -=\n  npm run start \n  yarn start\n  -=\n* 运行结果\n  1. ![运行结果](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGuBD6Ax0k6w847XnRhfbJZOQOv1W8D0VlUaI6Mys0cfXzb5D75RU.uFc5*HIml2zjKDCv8ES9*BdG3nytg2*u8I!/r)\n  2. ![点击按钮后的结果](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGgQ*nJHHPyDcVLhOBc.3wczAlu52iDZ7A4izSuMrxfj7T4MlhcKEI3ofQL7ZshrFtjFTcMNQ7JAmWPlfNVPTXvU!/r)\n\n\n\n## 6.Electron创建菜单与基本使用\n> [Menu](https://www.electronjs.org/docs/api/menu)创建原生应用菜单和上下文菜单\n* 本篇使用到的方法\n  1. =-Menu.buildFromTemplate(template)=- - 创建菜单，返回Menu  template是菜单模板\n  2. =-Menu.setApplicationMenu(m)=- - 设置菜单  m是第一个方法的返回值\n### 设置菜单的案例\n* 文件路径：\n  -=\n  ├─index.html  -- 主页面(渲染进程)\n  ├─index.js  -- 主进程\n  ├─package.json  -- 配置文件\n  ├─setting.html  -- 页面2\n  ├─main\n  |  └menu.js  -- 主进程菜单逻辑代码\n  -=\n* =-index.html=-文件代码：\n  -= html\n  <!DOCTYPE html>\n  <html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>菜单</title>\n  </head>\n  <body>\n    <h2>菜单测试页面</h2>\n  </body>\n  </html>\n  -=\n* =-index.js=-渲染进程文件\n  -= js\n  const {app,BrowserWindow} = require(\'electron\');\n  let mainWindow = null;\n  app.on("ready",()=>{\n    mainWindow = new BrowserWindow({\n      width:800,\n      height:500,\n      webPreferences:{\n        nodeIntegration:true\n      }\n    })\n    require(\'./main/menu.js\'); //引入设置菜单\n    mainWindow.loadFile(\'index.html\');\n    mainWindow.webContents.openDevTools(); //打开调试工具\n    mainWindow.on(\'closed\',()=>{\n      mainWindow = null;\n    })\n  });\n  -=\n* =-main/menu.js=-菜单逻辑代码(属于主进程)\n  -= js\n  const { Menu, BrowserWindow } = require(\'electron\');\n  var template = [\n    {\n      label:\'菜单1\',\n      submenu:[\n        { label:"菜单1-1" },\n        { \n          label:"菜单1-2",\n          accelerator:\'ctrl+f\' //快捷键\n        }\n      ]\n    },\n    {\n      label:\'菜单2\',\n      submenu:[\n        { label:\'菜单2-1\' },\n        { label:\'菜单2-2\' }\n      ]\n    },\n    {\n      label:\'设置\',\n      accelerator:\'ctrl+n\',\n      click:()=>{\n        let win = new BrowserWindow({\n          width:500,\n          height:500,\n          webPreferences:{\n            nodeIntegration:true\n          }\n        });\n        win.loadFile(\'setting.html\'); //引入设置界面\n        win.on(\'closed\',()=>{\n          win = null;\n        })\n      }\n    }\n  ];\n  //生成菜单\n  var m = Menu.buildFromTemplate(template);\n  //设置菜单\n  Menu.setApplicationMenu(m);\n  -=\n* =-setting.html=-页面2代码\n  -= html\n  <!DOCTYPE html>\n  <html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>设置</title>\n  </head>\n  <body style="background: #ccc;">\n    <h2>我是设置页面</h2>\n  </body>\n  </html>\n  -=\n* =-package.json=-文件代码\n  -= json\n  {\n    "name": "study_4",\n    "version": "1.0.0",\n    "description": "",\n    "main": "index.js",\n    "scripts": {\n      "start":"electron ."\n    },\n    "keywords": [],\n    "author": "",\n    "license": "ISC",\n    "devDependencies": {\n      "electron": "^8.0.0"\n    }\n  }\n  -=\n* 运行\n  -=\n  npm run start\n  yarn start\n  -=\n* 运行结果\n  ![运行结果图](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGsJ.x4SmcqHCLZGbW17PpzwUPnRV00os4iVJTMAC7lxQdQVcEMF5ISaREg7joqIBVGIYOGI.n.l97Hcb7Pf2Nlc!/r)\n* 点击设置菜单或者按下=-ctrl+n=-效果图\n  ![点击设置菜单效果图](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGj6GO8e6js1T8KGprarb*2RZ8Qeh90o.GAOjCQA4lfxfbTFE7BPtxaDrOmiqrl3RMssvH30Y3gETt6L7x3xOm9c!/r)\n* 二级菜单效果图\n  ![二级菜单效果图](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGu9jqiheisda4ER3.7JBgVXP3mBqi2fQCD9knyGj0T8DXwF682M9yjEjeWYIVS3oloSAlPXgC8GasE2XXq9e*wU!/r)\n\n\n\n## 7.Electron右键菜单\n* 右键菜单的相应事件是写在渲染进程中的，也就是在=-index.html=-中的，所以要是有=-remote=-模块进行操作\n> 创建右键菜单依旧使用[Menu](https://www.electronjs.org/docs/api/menu)模块，菜单绑定事件方式也与上一篇相同\n* 本片使用到的方法\n  1. =-Menu.buildFromTemplate(template)=- -- 返回Menu对象  template - 菜单模板\n  2. =-MenuObj.popup({})=- -- 将此菜单作为 browserWindow 中的上下文菜单弹出。 MenuObj是1返回的内容\n  3. =-getCurrentWindow()=- -- 返回 BrowserWindow - 此网页所属的窗口\n\n* 案例文件路径\n  -=\n  ├─index.html -- 渲染进程文件\n  ├─index.js   -- 主进程文件\n  ├─package.json  -- 配置文件\n  ├─render\n  |   └render.js -- 渲染进程逻辑文件\n  -=\n* =-index.html=-文件内容\n  -= html\n  <!DOCTYPE html>\n  <html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>右键菜单</title>\n  </head>\n  <body>\n    <h2>右键菜单设置</h2>\n    <script src="./render/render.js"><\/script>\n  </body>\n  </html>\n  -=\n* =-index.js=-文件内容\n  -= js\n  const {app, BrowserWindow} = require(\'electron\');\n  let win = null;\n  app.on(\'ready\',()=>{\n    win = new BrowserWindow({\n      width:800,\n      height:500,\n      webPreferences:{\n        nodeIntegration:true\n      }\n    });\n\n    win.loadFile(\'index.html\');\n    win.on(\'closed\',()=>{\n      win = null;\n    })\n  })\n  -=\n* =-render/render.js=-文件内容\n  -= js\n  const {Menu,getCurrentWindow} = require(\'electron\').remote;\n  const rightTemplate = [\n    {\n      label:\'复制\',\n      accelerator:\'ctrl+c\'\n    },\n    {\n      label:\'粘贴\',\n      accelerator:\'ctrl+v\'\n    }\n  ]\n  //生成菜单\n  let m = Menu.buildFromTemplate(rightTemplate);\n\n  window.addEventListener(\'contextmenu\',e =>{\n    e.preventDefault(); //阻止默认事件\n    m.popup({ //设置菜单\n      window:getCurrentWindow(), //返回BrowserWindow\n    })\n  })\n  -=\n* =-package.json=-文件内容\n  -= json\n  {\n    "name": "study_5",\n    "version": "1.0.0",\n    "description": "",\n    "main": "index.js",\n    "scripts": {\n      "start": "electron ."\n    },\n    "keywords": [],\n    "author": "",\n    "license": "ISC",\n    "devDependencies": {\n      "electron": "^8.0.1"\n    }\n  }\n  -=\n* 执行\n  -=\n  npm run start\n  yarn start\n  -=\n* 执行结果(右键)\n\n  ![运行效果](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGsR*NTXt4HRQxcp9BE6a7Tk2b5TM00ezUq0qiov.Gajz4Uo4xDsyK0g7QJrjPwqS9m*BlYuMzlPbSUFWGNHlDy4!/r)\n  \n  \n  \n## 8.通过浏览器打开链接 - shell模块\n> [shell](https://www.electronjs.org/docs/api/shell)模块可以既在渲染进程(==在渲染进程中不需要=-remote=-模块==)也可以主进程中使用\n* 本片使用到的方法\n  1. =-shell.openExternal(url)=- -- 在用户默认浏览器中打开url\n\n### 使用案例\n* 文件路径\n  -=\n  ├─index.html -- 渲染进程\n  ├─index.js   -- 主进程\n  ├─package.json -- 配置文件\n  ├─render\n  |   └render.js  -- 渲染进程逻辑\n  -=\n* =-index.html=-文件内容\n  -= html\n  <!DOCTYPE html>\n  <html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>通过浏览器打开链接</title>\n  </head>\n  <body>\n    <h1>\n      \x3c!-- 直接点击会在electron应用内打开 --\x3e\n      <a href="http://www.baidu.com">点击应用内打开百度</a>\n    </h1>\n    <hr>\n    <h1>\n      <a class="a1" href="http://www.baidu.com">点击在浏览器中打开百度</a>\n    </h1>\n    <script src="render/render.js"><\/script>\n  </body>\n  </html>\n  -=\n* =-index.js=-文件内容\n  -= js\n  const {app, BrowserWindow} = require(\'electron\');\n  let mainWin = null;\n\n  app.on(\'ready\',()=>{\n    mainWin = new BrowserWindow({\n      width:800,\n      height:500,\n      webPreferences:{\n        nodeIntegration:true\n      }\n    });\n    mainWin.loadFile(\'index.html\');\n    //打开开发者工具\n    mainWin.webContents.openDevTools();\n    mainWin.on(\'closed\',()=>{\n      mainWin = null;\n    })\n\n  });\n  -=\n* =-render.js=-文件内容\n  -= js\n  const {shell} = require(\'electron\');\n  let a1 = document.querySelector(\'.a1\');\n  a1.addEventListener(\'click\',(e)=>{\n    e.preventDefault();\n    let {href} = a1;\n    //在浏览器打开链接\n    //https://www.electronjs.org/docs/api/shell#shellbeep\n    shell.openExternal(href);\n    \n  })\n  -=\n* =-package.json=-文件内容\n  -= json\n  {\n    "name": "study_6",\n    "version": "1.0.0",\n    "description": "",\n    "main": "index.js",\n    "scripts": {\n      "start": "electron ."\n    },\n    "keywords": [],\n    "author": "",\n    "license": "ISC",\n    "devDependencies": {\n      "electron": "^8.0.1"\n    }\n  }\n\n  -=\n* 执行=-npm run start=-或者=-yarn start=-即可\n\n\n## 9.Electron嵌入网页和打开子窗口\n1. 嵌入网页\n    > [BrowserView](https://www.electronjs.org/docs/api/browser-view)可以实现类似于Web中=-<iframe>=-标签的效果(内嵌网页)，==BrowserView是主进程中的类，只能在主进程使用==\n    \n    * 示例代码 =-index.js=-主进程代码如下\n      -= js\n      const {app, BrowserWindow, BrowserView} = require(\'electron\');\n      app.on(\'ready\',()=>{\n        let mainWin = new BrowserWindow({\n          width:1000,\n          height:800,\n          webPreferences:{\n            nodeIntegration:true\n          }\n        });\n        mainWin.loadFile(\'index.html\');\n        mainWin.on(\'closed\',()=>{\n          mainWin = null;\n        })\n        \n        //嵌入页面代码\n        //https://www.electronjs.org/docs/api/browser-view\n        let view = new BrowserView(); //new出对象\n        mainWin.setBrowserView(view); //在主窗口中设置view可用\n        view.setBounds({\n          x:0, //距离x轴的距离\n          y:100,//距离y轴的距离\n          width:1000, //宽度\n          height:700 //高度\n        })\n        //view载入页面\n        view.webContents.loadURL(\'https://uniapp.dcloud.io/\');\n      });\n      -=\n    * 其他代码无变化\n    * 运行效果\n      ![BrowserView内嵌网页运行图](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGnDc69jBTi9ZS*QYVZF7SB3.inLiVrBF5Oag79USWWYFWy6CkY8SROSmj382MyJj4WiEA3G8GzkXfWINfXsK.XE!/r)\n\n2. 打开子窗口\n* 打开子页面使用=-window.open(url)=-方法\n* 只有=-window.open()=-打开的页面才算是子页面，之前使用=-BrowserWindow=-打开的页面不算子页面\n* 示例代码如下\n  * =-index.html=-渲染进程\n    -= html\n    <!DOCTYPE html>\n    <html lang="en">\n    <head>\n      <meta charset="UTF-8">\n      <meta name="viewport" content="width=device-width, initial-scale=1.0">\n      <meta http-equiv="X-UA-Compatible" content="ie=edge">\n      <title>内嵌网页</title>\n    </head>\n    <body>\n      <button class="btn1">点击打开子窗口</button>\n      <script src="render/render.js"><\/script>\n    </body>\n    </html>\n    -=\n  *=-render/render.js=-渲染进程逻辑文件\n    -= js\n    let btn1 = document.querySelector(\'.btn1\');\n    btn1.addEventListener(\'click\',()=>{\n      //window可以直接使用，不需要引入\n      window.open(\'http://www.baidu.com\')\n    })\n    -=\n  * 剩下的代码无变化\n  * 运行效果\n    ![window.open运行图](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGkYdgmx6CQ7qd75k93Ci*lsQvz1WUBCuo0gdwzJLRhcPKu1SzIXc4ATA.vU4JphrED496GdwhR8IDO99oM5ICaI!/r)\n    \n    \n    \n## 10.Electron父子窗口的通信\n> 子窗口向父窗口发送数据使用[window.opener.postMessage()](https://www.electronjs.org/docs/api/window-open#windowopenerpostmessagemessage-targetorigin)\n\n> 父窗口监听子窗口是数据监听=-message=-事件，例如使用=-window.addEventListener(\'message\',fn)=-\n\n##### 代码案例\n* 文件路径\n    -=\n    ├─child.html -- 子窗口\n    ├─index.html -- 主窗口\n    ├─index.js  -- 主进程\n    ├─package.json -- 配置文件\n    ├─render\n    |   └render.js  -- 主进逻辑文件\n    -=\n* =-index.html=-文件代码\n    -= html\n    <!DOCTYPE html>\n    <html lang="en">\n    <head>\n      <meta charset="UTF-8">\n      <meta name="viewport" content="width=device-width, initial-scale=1.0">\n      <meta http-equiv="X-UA-Compatible" content="ie=edge">\n      <title>主页面</title>\n    </head>\n    <body>\n      <h2>主页面</h2>\n      <button id="btn1">点击打开子窗口</button>\n      <div class="container"></div>\n      <script src="./render/render.js"><\/script>\n    </body>\n    </html>\n    -=\n* =-index.js=-文件代码\n    -= js\n    const {app,BrowserWindow} = require(\'electron\');\n    app.on(\'ready\',()=>{\n      let win = new BrowserWindow({\n        width:800,\n        height:500\n      });\n      win.loadFile(\'index.html\');\n      win.on(\'closed\',()=>{\n        win = null;\n      })\n    })\n    -=\n* =-render.js=-文件代码\n    -= js\n    let btn = document.querySelector(\'#btn1\');\n    btn.addEventListener(\'click\',()=>{\n      //打开子窗口\n      window.open(\'./child.html\')\n    })\n    //监听子窗口通信\n    window.addEventListener(\'message\',msg=>{\n      //msg是一个对象  msg.data是传值的内容\n      let container = document.querySelector(\'.container\');\n      container.innerHTML = msg.data;\n    })\n    -=\n* =-child.html=-文件代码\n    -= html\n    <!DOCTYPE html>\n    <html lang="en">\n    <head>\n      <meta charset="UTF-8">\n      <meta name="viewport" content="width=device-width, initial-scale=1.0">\n      <meta http-equiv="X-UA-Compatible" content="ie=edge">\n      <title>子页面</title>\n    </head>\n    <body>\n      内容：<input class="inp1" type="text" value="" placeholder="请输入通信内容">\n      <button class="btn1">点击向父页面传值</button>\n      <script>\n      let btn1 = document.querySelector(\'.btn1\');\n      btn1.addEventListener(\'click\',e=>{\n        let {value} = document.querySelector(\'.inp1\');\n        //发起通信\n        window.opener.postMessage(value);\n      })\n      <\/script>\n    </body>\n    </html>\n    -=\n* =-package.json=-部分文件代码\n    -= json\n    "scripts": {\n        "start":"electron ."\n    },\n    -=\n* 运行=-npm run start=-或者=-yarn start=-\n* 运行结果\n    ![父窗口运行结果](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGpf0sdLBJu1Gm0QUS9UomEsmuByfNFwzGLWnWlL5G72jvhQlfMO7M8oVw3d0ndR*lwubCaBkq0V7hHil6JKNH0M!/r)\n\n    ![子窗口运行结果](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGtaTJkYZiEhgLcI8zju8Z*hv9c95Cp404UlxbI1GN044iaPmxBMQxAlLPpfK6GgGQmgPLJFrR9gBjtEEGTuFkwI!/r)\n    \n    \n    \n## 11.Electron选择文件对话框\n> 打开对话框使用[dialog.showOpenDialog()](https://www.electronjs.org/docs/api/dialog#dialogshowopendialogbrowserwindow-options)\n* =-dialog.showOpenDialog({})=-参数\n    * =-title=-：String（可选），对话框的标题\n    * =-defaultPath=-：String（可选），默认打开的路径\n    * =-buttonLabel=-：String（可选），确定按钮自定义内容 默认为 打开\n    * =-filters=-：Array（可选），文件选择过滤器，可以对文件后缀名进行筛选\n    * =-properties=-：String（可选），打开文件的属性，比如打开文件还是打开文件夹，甚至是隐藏文件。\n##### demo练习\n* 文件目录\n    -=\n    ├─index.html  -- 渲染进程\n    ├─index.js -- 主进程\n    ├─package.json -- 配置文件\n    ├─render\n    |   └render.js -- 渲染进程逻辑文件\n    -=\n* =-index.html=-文件内容\n    -= html\n    <!DOCTYPE html>\n    <html lang="en">\n    <head>\n      <meta charset="UTF-8">\n      <meta name="viewport" content="width=device-width, initial-scale=1.0">\n      <meta http-equiv="X-UA-Compatible" content="ie=edge">\n      <title>文件选择</title>\n    </head>\n    <body>\n      <button class="openBtn">点击选择图片</button>\n      <img src="" style="width:100%" class="img1">\n      \x3c!-- 引入逻辑代码 --\x3e\n      <script src="./render/render.js"><\/script>\n    </body>\n    </html>\n    -=\n* =-index.js=-文件内容\n    -= js\n    const {app, BrowserWindow} = require(\'electron\');\n    app.on(\'ready\',()=>{\n      let win = new BrowserWindow({\n        width:1000,\n        height:800,\n        webPreferences:{\n          nodeIntegration:true\n        }\n      });\n      win.loadFile(\'index.html\');\n      win.on(\'closed\',()=>{\n        win = null;\n      });\n    })\n    -=\n* =-render.js=-文件内容\n    -= js\n    const { dialog } = require(\'electron\').remote;\n    const openBtn = document.querySelector(\'.openBtn\');\n    openBtn.addEventListener(\'click\',e=>{\n      // https://www.electronjs.org/docs/api/dialog\n      dialog.showOpenDialog({\n        title:\'请选择要打开的图片\', //标题\n        // defaultPath:\'\', //打开是默认路径\n        buttonLabel:\'确定选择\', //确定按钮自定义内容 -默认为 打开\n        filters:[\n          {\n            name:\'img\',extensions:[\'jpg\',\'png\',\'jpeg\',\'gif\']\n          }\n        ]\n      }).then(res=>{\n        console.log(res);\n        if(res.canceled){\n          //点击取消\n          return;\n        }\n        const img1 = document.querySelector(\'.img1\');\n        img1.src = res.filePaths[0];\n      }).catch(err=>{\n        console.log(\'选择错误->\',err);\n      })\n    })\n    -=\n* =-package.json=-文件\n    -= json\n    "scripts": {\n        "start": "electron ."\n      },\n    -=\n* 执行=-yarn start=-\n* 执行结果\n    ![打开效果](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGmmbs2x3wrKhH5jjfCCXxMgjYVPfq6i38kO8J9TBhqMLHySV6Omc5eRBtsR3SexTF1oeRrRG08pWXNJ9GM4dYCo!/r)\n* 点击按钮效果\n    ![对话框效果](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGjXe.eD6nVDfvOkxW9DLiteiDfl1byGSMYswSKMPP4H8nnqMwGhwR5GvcF0fuaEbsG3cC0yLr1DI*pGREYM0.Lc!/r)\n* 选择文件之后效果\n    ![选择文件完成效果图](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGvOsdWjthHr.LF1zHDb6TXIYJfeK.9.0Y*XglN7j7rhgjWNF*6V.2WQkr0aCAd.OREiO.zAAh*wX.kaHjOdphxs!/r)\n\n\n\n## 12.Electron保存(创建)文件对话框\n> 打开对话框使用[dialog.showSaveDialog()](https://www.electronjs.org/docs/api/dialog#dialogshowsavedialogbrowserwindow-options)\n* =-dialog.showSaveDialog({})=-参数\n    * =-title=-：String（可选），对话框的标题\n    * =-defaultPath=-：String（可选），默认打开的路径\n    * =-buttonLabel=-：String（可选），确定按钮自定义内容 默认为 保存\n    * =-filters=-：Array（可选），文件选择过滤器，可以对文件后缀名进行筛选\n    * =-properties=-：String（可选），打开文件的属性，比如打开文件还是打开文件夹，甚至是隐藏文件。\n    * \n##### demo练习\n* 文件目录\n    -=\n    ├─index.html -- 渲染进程\n    ├─index.js  -- 主进程\n    └package.json\n    -=\n* =-index.html=-文件内容\n    -= html\n    <!DOCTYPE html>\n    <html lang="en">\n    <head>\n      <meta charset="UTF-8">\n      <meta name="viewport" content="width=device-width, initial-scale=1.0">\n      <meta http-equiv="X-UA-Compatible" content="ie=edge">\n      <title>保存文件对话框</title>\n    </head>\n    <body>\n      <button class="saveBtn">保存文件</button>\n      <script>\n        const { dialog } = require(\'electron\').remote\n        const fs = require(\'fs\');\n        let saveBtn = document.querySelector(\'.saveBtn\');\n        saveBtn.addEventListener(\'click\',e=>{\n          //保存文件\n          dialog.showSaveDialog({\n            title:\'保存文件\'\n          }).then(res=>{\n            if(res.canceled){\n              console.log(\'用户点击取消\');\n              return;\n            }\n            //写入内容\n            fs.writeFileSync(res.filePath,\'文件内容内容内容内容内容内容\');\n            console.log(\'保存成功->\',res);\n          }).catch(err=>{\n            console.log(\'保存失败->\',err);\n          })\n        })\n      <\/script>\n    </body>\n    </html>\n    -=\n* =-index.js=-文件内容\n    -= js\n    const {app,BrowserWindow} = require(\'electron\');\n    app.on(\'ready\',()=>{\n      let win = new BrowserWindow({\n        width:800,\n        height:500,\n        webPreferences:{\n          nodeIntegration:true\n        }\n      });\n      win.loadFile(\'index.html\');\n      win.on(\'closed\',()=>{\n        win = null;\n      })\n    })\n    -=\n* =-package.json=-的=-scripts=-部分代码\n    -= json\n    "scripts": {\n      "start": "electron ."\n    },\n    -=\n* 运行=-yarn start=-\n* 运行结果\n    ![运行效果](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGsSQpEv.xbL04k27I5EU1TdiR0KFifCp7668Ctm6zQQ3drU57D9bNHuic5l4HObb6hts3vdFENGaUVXHPqlbois!/r)\n* 点击按钮弹出对话框效果\n    ![弹出对话框效果图](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGn1.NdduUBl3EPdb0Dhvdqk.JKKbRi0O81xYfD1vii*ahOVWV4nAOk*5KbqErjbxgWv8iyLn6RtuYh*71IQAFCo!/r)\n* 打开文件效果图\n    ![打开文件效果图](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGvVqjz9gVFY4o2pRzXn8yRCe**7ICbpv7c8svDSPzmXQGnaISRP8puWLEUeTZIBkZsMIW8c7rzcGCA9l7FIz.20!/r)\n    \n    \n\n## 13.Electron消息对话框\n> 消息对话框使用[dialog.showMessageBox()](https://www.electronjs.org/docs/api/dialog#dialogshowmessageboxbrowserwindow-options)\n* =-dialog.showMessageBox()=-参数说明\n    * =-type=-：String类型，可选，可以为=-none=-,=-info=-,=-error=-,=-question=-或者=-warning=-.在Windows平台上=-question=-和=-info=-图标相同,在macOS上=-warning=-和=-error=-会显示相同图标\n    * =-title=-：String类型，可选。MessageBox的标题，_一些平台不显示_\n    * =-message=-：String类型，MessageBox的内容\n    * =-detail=-：String类型，可选。MessageBox的额外信息\n    * =-buttons=-：Array类型，按钮的文本数组，在windows上，空数组会显示“OK”，返回的是被点击按钮的索引\n    * =-defaultId=-：Number(整型)，可选，默认选中的按钮，值为=-buttons=-数组中的索引\n    * 更多不常用参数：[点击查看文档](https://www.electronjs.org/docs/api/dialog#dialogshowmessageboxbrowserwindow-options)\n##### 演示demo\n* 文件路径\n    -=\n    ├─index.html -- 渲染进程\n    ├─index.js  -- 主进程\n    └package.json\n    -=\n* =-index.html=-文件内容\n    -= html\n    <!DOCTYPE html>\n    <html lang="en">\n    <head>\n      <meta charset="UTF-8">\n      <meta name="viewport" content="width=device-width, initial-scale=1.0">\n      <meta http-equiv="X-UA-Compatible" content="ie=edge">\n      <title>消息对话框</title>\n    </head>\n    <body>\n      <div class="radioDiv">\n        <h2>图标样式</h2>\n        <span><input type="radio" name="icon-type" value="none" checked> 无 </span>\n        <span><input type="radio" name="icon-type" value="info"> 信息 </span>\n        <span><input type="radio" name="icon-type" value="error"> 错误 </span>\n        <span><input type="radio" name="icon-type" value="warning"> 警告 </span>\n        <span><input type="radio" name="icon-type" value="question"> 疑问 </span>\n      </div>\n      <button class="messageBtn">点击弹出消息对话框</button>\n      <script>\n        const {dialog} = require(\'electron\').remote; \n        const messageBtn = document.querySelector(\'.messageBtn\');\n        messageBtn.addEventListener(\'click\',()=>{\n          let radio = document.querySelector(\'input[name=icon-type]:checked\');\n          let {value} =radio;\n          dialog.showMessageBox({\n            type:value,\n            title:value+\'类型\',\n            defaultId:1,\n            message:\'提示内容内容内容内容内容\',\n            detail:\'额外信息信息信息信息信息信息\',\n            buttons:[\'按钮1\',\'按钮2\',\'按钮3\']\n          }).then(res=>{\n            console.log(\'res->\',res);\n            let {response} = res;\n            window.alert(=-按钮$-response+1}被点击=-);\n          }).catch(err=>{\n            console.log(\'错误->\',err);\n          })\n        })\n      <\/script>\n    </body>\n    </html>\n    -=\n* =-index.js=-文件内容\n    -= js\n    const {app,BrowserWindow} = require(\'electron\');\n    app.on(\'ready\',()=>{\n      let win = new BrowserWindow({\n        width:800,\n        height:500,\n        webPreferences:{\n          nodeIntegration:true\n        }\n      });\n      win.loadFile(\'index.html\');\n      win.on(\'closed\',()=>{\n        win = null;\n      })\n    })\n    -=\n* =-package.json=-的=-scripts=-内容\n    -= json\n    "scripts": {\n      "start": "electron ."\n    },\n    -=\n* 效果图\n ![运行效果图](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGgWSXcaWEk2s1iPcVNt.RkPMo3pPdSC9ML9V5KOVtDihKnQ9JyHRuZ0tw5Bbj.nnERpIZKprLh2pwK4wYUSkP0U!/r)\n ![弹窗效果图](http://r.photo.store.qq.com/psc?/V1021XMO1TUVn3/tS3tY63exiZNUWwJevnZGomvpUhqesn6tTnlRl02xSJhMsVmDZ9WiITyr4aPXFGyMrhIiV3E9G5**KEAI9pA2rICawG2MGqWWkhhN8B2Nos!/r)\n \n \n \n## 14.Electron监听网络连接\n### electon客户端监听网络连接判断网络状态，可以使用=-window.addEventListener()=-来进行事件监听\n> #### 相关事件\n* online：连接上网络就会触发该事件 (如果连接着网络打开应用不会触发)\n* offline：网络断开会触发该事件\n* ####  用法 - 直接在渲染进程中写入以下代码：\n    -= js\n    window.addEventListener(\'online\',function(){\n        //监听网络连接\n        alert(\'官人，我来了，我们继续哦！\')\n    })\n    window.addEventListener(\'offline\',function(){\n        // 监听网络断开\n        alert(\'小女子先行离开一会，请稍等！\')\n    })\n    -=\n### electron的底部消息通知是通过=-H5=-的 [window.Natification](https://developer.mozilla.org/zh-CN/docs/Web/API/notification) 来实现的\n> ### window.Notification(title,option)的参数属性\n* title：通知的标题\n* option：消息的各种配置(可选)\n    * dir：文字的方向；auto-自动 ltr-从左到右 rtl-从右到左\n    * lang: 指定通知中所使用的语言。这个字符串必须在 BCP 47 language tag 文档中是有效的。\n    * body - 通知中额外显示的字符串（内容）\n    * tag: 赋予通知一个ID，以便在必要的时候对通知进行刷新、替换或移除。\n    * icon: 一个图片的URL，将被用于显示通知的图标。\n\n#### 用法 (渲染进程中使用)\n  -= html\n  <!DOCTYPE html>\n  <html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>底部消息通知</title>\n  </head>\n  <body>\n    <button class="btn1">点击通知</button>\n    <script>\n    let btn1 = document.querySelector(\'.btn1\');\n    let option = {\n      title:\'我是提示\',\n      body:\'我是提示额外内容.....\'\n    }\n\n    btn1.addEventListener(\'click\',()=>{\n      new window.Notification(\'我是提示\',{\n        body:\'我是提示额外显示的内容\'\n      })\n    })\n    <\/script>\n  </body>\n  </html>\n  -=\n    \n    \n \n## 15.Electron注册全局快捷键\n> #### 注册全局快捷键需要用到[globalShortcut](https://www.electronjs.org/docs/api/global-shortcut)模块，=-globalShortcut=-是主进程中的模块(在渲染进程中需要使用=-remote=-)\n##### 本文使用到的方法\n* =-globalShortcut.register(\'快捷键\',fn())=- --- 注册快捷键\n* =-globalShortcut.isRegistered(\'快捷键\')=-  --- 检测快捷键是否注册成功 返回true/false\n* =-globalShortcut.unregister(\'快捷键\')=-    --- 注销某个快捷键\n* =-globalShortcut.unregisterAll()=-         --- 注销所有快捷键\n\n##### 代码示例\n* =-index.html=- -- 渲染进程\n    -= html\n    <!DOCTYPE html>\n    <html lang="en">\n    <head>\n      <meta charset="UTF-8">\n      <meta name="viewport" content="width=device-width, initial-scale=1.0">\n      <meta http-equiv="X-UA-Compatible" content="ie=edge">\n      <title>全局快捷键</title>\n    </head>\n    <body>\n      <h2>ctrl+o加载网页，ctrl+m显示底部通知栏</h2>\n      <button class="register-btn-m">注销 ctrl+m 快捷键</button>\n      <button class="register-btn-all">注销全部快捷键</button>\n      <script>\n        const { globalShortcut} = require(\'electron\').remote;\n        globalShortcut.register(\'ctrl+m\',()=>{\n          new window.Notification(\'快捷键被点击\',{\n            body:\'ctrl+m被点击\'\n          })\n        })\n        let isMRegister = globalShortcut.isRegistered(\'ctrl+m\');\n        if(!isMRegister){\n          //注册失败(快捷键冲突处理)\n          window.alert(\'注册ctrl+m失败\');\n        };\n        //解绑快捷键\n        let btn = document.querySelector(\'.register-btn-m\');\n        let btnAll = document.querySelector(\'.register-btn-all\');\n        btn.addEventListener(\'click\',e=>{\n          globalShortcut.unregister(\'ctrl+m\');\n          window.alert(\'清空快捷键成功\')\n        })\n        btnAll.addEventListener(\'click\',e=>{\n          globalShortcut.unregisterAll();\n          window.alert(\'清空快捷键成功\')\n        })\n      <\/script>\n    </body>\n    </html>\n    -=\n* =-index.js=- -- 主进程\n    -= js\n    const {app, BrowserWindow, globalShortcut} = require(\'electron\');\n\n    app.on(\'ready\',()=>{\n      let win = new BrowserWindow({\n        width:800,\n        height:500,\n        webPreferences:{\n          nodeIntegration:true\n        }\n      });\n      //注册快捷键\n      globalShortcut.register(\'ctrl+o\',()=>{\n        win.loadURL(\'http://www.huya.com\');\n      })\n      //检测快捷键是否注册成功 -- 返回true/false\n      let isORegister = globalShortcut.isRegistered(\'ctrl+o\');\n      if(!isORegister){\n        //注册失败(快捷键冲突处理)\n        window.alert(\'注册ctrl+o失败\');\n      };\n      \n      win.loadFile(\'index.html\');\n      win.on(\'closed\',()=>{\n        win = null;\n      })\n    })\n    // Electron 会首先关闭所有的窗口然后触发 will-quit 事件\n    app.on(\'will-quit\',()=>{ //关闭时注销所有全局快捷键\n      //注销所有的全局快捷键\n      globalShortcut.unregisterAll();\n    })\n    -=\n\n\n\n## 16.Electron剪切板的使用(clipboard)\n> ### 需要使用到 [clipboard](https://www.electronjs.org/docs/api/clipboard)\n#### 点击按钮复制激活码案例：\n* index.html\n    -= html\n    <!DOCTYPE html>\n    <html lang="en">\n    <head>\n      <meta charset="UTF-8">\n      <meta name="viewport" content="width=device-width, initial-scale=1.0">\n      <meta http-equiv="X-UA-Compatible" content="ie=edge">\n      <title>Document</title>\n    </head>\n    <body>\n      <p class="text"我是文本内容</p>\n      <button class="btn">点击复制</button>\n      <script>\n        let { clipboard } = require(\'electron\');\n        let text = document.querySelector(\'.text\');\n        let btn = document.querySelector(\'.btn\');\n        btn.addEventListener(\'click\',e=>{\n          clipboard.writeText(text.innerHTML);\n        })\n      <\/script>\n    </body>\n    </html>\n    -=\n* index.js\n    -= js\n    const {app,BrowserWindow} = require(\'electron\');\n    app.on(\'ready\',()=>{\n      let win = new BrowserWindow({\n        width:800,\n        height:500,\n        webPreferences:{\n          nodeIntegration:true\n        }\n      })\n      win.loadFile(\'index.html\');\n      win.on(\'closed\',()=>{\n        win = null\n      })\n    })\n    -=\n    \n    \n    \n## 17.electron应用打包\n#### 1. 定位到项目根目录\n#### 2. 使用=-npm=-或者=-yarn=-安装=-electron-packager=-\n-=\n//npm\nnpm install electron-packager --save-dev\ncnpm install electron-packager --save-dev\n//yarn\nyarn add electron-packager --dev\n-=\n#### 打包方法1(不推荐)\n* 第一种打包方法就是直接在命令行中输入electron-packager,然后后边跟着6个打包参数\n\n-=\n\nelectron-packager <location of project> <name of project> <platform> <architecture> <electron version> <optional options>\n\n//参数说明\nlocation of project : 项目所在路径\nname of project : 打包的项目名称\nplatform : 确定了你要构建哪个平台的应用（Windows、Mac还是Liux）\narchitecture: 决定了使用x86还是x64还是两个架构都需要\nelectron version: electron 的版本\noptional options: 其他可选选项\n-=\n#### 打包方法2\n* 打开=-package.json=-文件，在=-scripts=-下添加代码\n\n-=\nelectron-packager ./ HelloWorld --all --out ./outApp --arch=x64 --electron-version 8.2.3  --overwrite --icon=./app/logo72.png\n\n//说明\nelectron-packager ./ 软件名称 --all(平台) --out ./outApp(输出路径) --arch=x64 --electron-version 8.2.3(electron版本)  --overwrite --icon=./app/logo72.icon(图标)\n-=\n* 在项目中新建=-outApp=-文件夹\n* 使用=-npm run-scripts packager=-\n\n\n',l=[r,""],a={data:function(){return{detailId:0,mdText:""}},beforeMount:function(){this.detailId=this.$route.params.id;var n=l[this.detailId].replaceAll("-=","```");n=n.replaceAll("=-","`"),n=n.replaceAll("$-","${"),this.mdText=n}},s=a,c=(t("1e75"),t("2877")),d=Object(c["a"])(s,o,i,!1,null,"7c6fa05d",null);e["default"]=d.exports}}]);
//# sourceMappingURL=chunk-61ecc344.2cdacdf2.js.map